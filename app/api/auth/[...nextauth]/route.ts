import GoogleProvider from 'next-auth/providers/google';
import { CLIENT_ID, CLIENT_SECRET } from '@/constants';
import { MongoDBAdapter } from '@auth/mongodb-adapter';
import { NextApiHandler } from 'next';
import NextAuth, { AuthOptions } from 'next-auth';
import clientPromise from '@/lib/mongodb';
import { signJwt } from '@/lib/jwt';
import { JwtPayload } from '@/types/jwt';
import { cookies } from 'next/headers';
import CredentialsProvider from 'next-auth/providers/credentials';
import { OAuth2Client } from 'google-auth-library';

const googleAuthClient = new OAuth2Client(CLIENT_ID);

type OneTapCredentials = {
  clientId: string;
  clientSecret: string;
  credential: string; // JWT token
  select_by: string;
}

const adapter = MongoDBAdapter(clientPromise) as AuthOptions['adapter']

export const OPTIONS: AuthOptions = {
  adapter: adapter,
  providers: [
    GoogleProvider({
      clientId: CLIENT_ID,
      clientSecret: CLIENT_SECRET,
    }),
    CredentialsProvider({
      id: 'googleonetap',
      name: 'google-one-tap',
      // This field define what parameter we expect from the FE and what's its name. In this case "credential"
      // This field will contain the token generated by google
      credentials: {
        credential: { type: 'text' },
      },

      // This is where all the logic goes
      authorize: async (credentials) => {
        // The token given by google and provided from the frontend
        const token = (credentials as unknown as OneTapCredentials).credential;
        // We use the google library to exchange the token with some information about the user
        const ticket = await googleAuthClient.verifyIdToken({
          // The token received from the interface
          idToken: token,
          // This is the google ID of your application
          audience: CLIENT_ID,
        });
        const payload = ticket.getPayload(); // This is the user

        if (!payload) {
          throw new Error('Cannot extract payload from signin token');
        }

        // If the request went well, we received all this info from Google.
        const { email, sub, given_name, family_name, email_verified, picture: image } = payload;

        // If for some reason the email is not provided, we cannot login the user with this method
        if (!email) {
          throw new Error('Email not available');
        }

        // Let's check on our DB if the user exists
        if (!adapter?.getUserByEmail || !adapter?.createUser || !adapter?.getUserByAccount || !adapter?.linkAccount) {
          throw new Error('Adapter not available');
        }

        let user = await adapter.getUserByEmail(email);

        // If there's no user, we need to create it
        if (!user) {
          user = await adapter.createUser({
            name: [given_name, family_name].join(' '),
            email,
            image,
            emailVerified: email_verified ? new Date() : null,
          });
        }

        // Let's also retrieve any account for the user from the DB, if any
        const account = user && (await adapter.getUserByAccount!({ provider: 'google', providerAccountId: sub }));

        // In case the account is not yet present on our DB, we want to create one and link to the user
        if (!account && user) {
          await adapter.linkAccount({
            userId: user.id,
            provider: 'google',
            providerAccountId: sub,
            accessToken: null,
            accessTokenExpires: null,
            type: 'oauth',
          });
        }
        // We can finally returned the retrieved or created user
        return user;
      },
    }),
  ],
  secret: process.env.NEXT_AUTH_SECRET,
  session: {
    strategy: 'jwt',
  },
  callbacks: {
    async jwt({ token, user, account }) {
      if (user && account) {
        token.id = user.id;
        const jwt = await signJwt({
          sub: token.sub,
          expires_at: account.expires_at,
          user: {
            id: user.id,
            name: user.name,
            email: user.email,
            image: user.image,
          },
        } satisfies JwtPayload);
        token.accessToken = jwt;
        cookies().set('auth_token', jwt);
      }
      return token;
    },
    async session({ session, token, user }) {
      session = { ...session, ...token, ...user };
      return session;
    },
  },
};

const authHandler: NextApiHandler = (req, res) => NextAuth(req, res, OPTIONS);

export { authHandler as GET, authHandler as POST };
